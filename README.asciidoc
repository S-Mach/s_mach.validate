= s_mach.validate: data validators
Lance Gatlin <lance.gatlin@gmail.com>
v1,8-Jun-2015
:blogpost-status: unpublished
:blogpost-categories: s_mach, scala

+s_mach.validate+ is an open-source Scala library that provides methods for easily building reuseable, composable and
serialization format agnostic data validators.

== Features
* Validators test data against one or more rules and produce a human-readable list of validation failures.
* Validators return +List[Rule]+ which is serialization format agnostic.
* Validators can output a light-weight human-readable "schema" of all rules tested and the expected type of each
primitive field or value.
* Convenience methods for converting +List[Explain]+ or +List[Rule]+ to Play JSON are provided.
* Validators can be composed with existing Play Format/Reads.

== Why do I need this?

* You want to write validation code once in a single place that can be reused in many places for various serialization
formats.
* You want a validation DSL that is light-weight, terse, reuseable and composable.
* You want to be able to display a light-weight human-readable schema derived from the validator DSL.
* You want to be able to create instances that might contain invalid data (as opposed to construction based
validation that prevents creating invalid instances) to allow fixing, serializing or transmitting structurally correct
but possibly invalid data.

== Include in SBT
TODO

== Example

----
Welcome to Scala version 2.11.6 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_40).
Type in expressions to have them evaluated.
Type :help for more information.

scala> :paste
// Entering paste mode (ctrl-D to finish)

import s_mach.validate._
import play.api.libs.json._
import s_mach.validate.play_json._

implicit class Name(
  val underlying: String
) extends AnyVal with IsValueType[String]
object Name {
  implicit val valueType_Name = ValueType[Name, String](
    new Name(_),
    _.underlying
  )
  implicit val validator_Name =
    Validator.forValueType[Name, String] {
      import Text._
      nonEmpty and maxLength(64) and allLettersOrSpaces
    }
}

implicit class Age(
  val underlying: Int
) extends AnyVal with IsValueType[Int]
object Age {
  implicit val valueType_Age = ValueType[Age,Int](
    new Age(_),
    _.underlying
  )
  implicit val validator_Age = {
    import Validator._
    forValueType[Age,Int](
      ensure(s"must be between (0,150)") { age =>
        0 <= age && age <= 150
      }
    )
  }
}

case class Person(id: Int, name: Name, age: Age)

object Person {
  implicit val validator_Person = {
    import Validator._

    forProductType[Person] and
    ensure(
      "age plus id must be less than 1000"
    )(p => p.id + p.age < 1000)
  }

  implicit val format_Person = Json.format[Person].withValidator
}

// Exiting paste mode, now interpreting.

import s_mach.validate._
import play.api.libs.json._
import s_mach.validate.play_json._
defined class Name
defined object Name
defined class Age
defined object Age
defined class Person
defined object Person

scala> Person(1,"!!!",200)
res0: Person = Person(1,!!!,200)

scala> res0.validate
res1: List[s_mach.validate.Rule] = List(name: must contain only letters or spaces, age: must be between (0,150))

scala> Json.toJson(res0)
res2: play.api.libs.json.JsValue = {"id":1,"name":"!!!","age":200}

scala> Json.fromJson[Person](res2)
res3: play.api.libs.json.JsResult[Person] = JsError(ArrayBuffer((/age,List(ValidationError(List(must be between (0,150)),WrappedArray()))), (/name,List(ValidationError(List(must contain only letters or spaces),WrappedArray())))))

scala> validator[Person].explain.prettyPrintJson
res4: String =
{
  "this" : "age plus id must be less than 1000",
  "id" : [ "must be integer" ],
  "name" : [ "must be string", "must not be empty", "must not be longer than 64 characters", "must contain only letters or spaces" ],
  "age" : [ "must be integer", "must be between (0,150)" ]
}

----
